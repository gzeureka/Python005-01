### 在你目前的工作场景中，哪个业务适合使用 rabbitmq？ 引入 rabbitmq 主要解决什么问题?（非相关工作可以以设计淘宝购物和结账功能为例来描述）
业务场景：酒店行业中，根据客户的消费行为（餐饮、购物、住房、休闲娱乐），计算客户的积分，根据积分给予相应的奖励。
旧系统用传统的关系数据库，每天凌晨对数据进行批量计算，更新客户积分并给予奖励。
引入消息队列（例如rabbitmq）后，将客户消费产生的交易数据放进消息队列中，由消费者程序监听消息，实时计算并更新客户的积分，给予奖励。这样带来的改进是架构上将数据的产生与数据的处理解耦，方便添加不同的数据处理程序（数据处理程序只需关心统一的消息格式即可）；业务上带来更及时的数据，更快速的响应，便于拓展业务。

### 如何避免消息重复投递或重复消费？
#### 消息重复投递问题：
消息中间件如果能更加消息的ID进行去重，那么可以避免消息被重复投递到队列中。

如果消息中间件没有这个功能，但可以查询最后一条消息，那么可以对消息进行编号，生产者启动时，按编号知道已经投递到第几条消息，继续进行投递。

如果上述方案都不可行，可以允许重复投递，但在消费时通过幂等性保证相同消息只被处理一次（或者处理多次但效果于处理一次相同）。

#### 消息重复消费问题：
例如有唯一约束的系统（例如数据库）记录已处理过的消息ID，可以避免对同一消息的重复处理。

或者将消息的语义本身做成幂等的，这样即使重复处理，但维持消息处理后的效果不变。

### 交换机 fanout、direct、topic 有什么区别？
**交换机**的作用是根据交换机的类型和路由规则，将消息路由至不同的队列。

**direct** 根据消息中的 routing key R 将消息路由至绑定了 routing key R 的队列上。每个消息被路由至一个队列。适用于对不同消息分开处理的应用场景，例如多个消费者分担处理消息的任务；或者某个消费者只处理某种类型的消息。

**fanout** 将消息路由至绑定的所有队列中，相当于一个消息被复制分发（广播）到所有绑定的队列。适用于对相同的消息进行不同处理的应用场景，例如一个消费者用作统计，一个消费者用作根据消息触发某个业务逻辑等。

**topic** 根据消息中的 routing key R（`.`分隔的字符串），以及绑定队列时指定的 pattern （允许通配符`*`和`#`）对消息进行路由，适用多播的场景，例如某几个客户端对某种key模式的消息感兴趣。

### 架构中引入消息队列是否利大于弊？你认为消息队列有哪些缺点？
架构中引入消息队列有以下优点：
- 服务局实现异步通信，避免同步调用的阻塞
- 按顺序消费数据，实现需要顺序执行的业务逻辑
- 消息队列通常写入速度比关系数据库要快，对大量进入的数据可进行流量削峰，并且让消费者按照自己的速率消费数据，或者用多个消费者进行负载均衡，避免压垮消费者。
- 对数据的产生以及数据的消费逻辑进行解耦，便于多个团队并行开发，添加不同类型的数据消费者进行业务拓展，充分利用数据的价值。
- 将并发的请求进行排队，适配处理速率
- 持久化的消息队列还可以成为数据分发的中心，接入不同系统。例如现在常见的 Kafka 加流处理系统组成 Kappa 架构。

以及带来的问题：
- 引入新的系统，增加需要学习和维护的部分
- 分布式的消息系统也需要面对高可用、数据一致性等经典问题

在今天应用系统数据量越来越大，业务种类越来越多的情况下，引入消息中间件是很有吸引力的。如果有成熟的运维团队或者能利用云上的消息服务，实施起来成功的机会高些。
